Pour ce projet, j’ai voulu comprendre comment Java peut gérer le couplage faible et l’injection de dépendances. L’idée était de séparer le code qui fournit les données de celui qui fait les calculs. Comme ça, si on change la source des données plus tard, on ne touche pas à la logique métier. Au début, j’étais un peu perdu avec toutes les façons d’injecter les dépendances, mais après avoir testé la statique, la dynamique et Spring, ça devient beaucoup plus clair.

J’ai commencé par créer l’interface IDao avec une méthode simple getData() qui retourne un nombre. Ensuite, j’ai fait deux implémentations : DaoImpl, qui simule une base de données, et DaoImpl2, qui simule un Web Service. L’idée est de pouvoir changer la source de données sans toucher au reste du code. Ensuite, j’ai créé l’interface IMetier avec la méthode calcul(). La classe MetierImpl utilise un IDao pour récupérer les données et les multiplier par 100. Ici, on voit que MetierImpl ne connaît pas l’implémentation exacte, juste l’interface. Cela rend le code beaucoup plus facile à modifier et à maintenir.

La première façon que j’ai testée s’appelle l’injection statique. Ici, on crée directement les objets dans le code avec le mot "new". Par exemple, j’ai fait "DaoImpl2 d = new DaoImpl2();" et ensuite "MetierImpl metier = new MetierImpl(d);". C’est simple et ça marche, mais si on veut changer le DAO plus tard, il faut modifier le code, ce qui n’est pas pratique pour de gros projets. J’ai trouvé ça très facile à mettre en place pour tester rapidement, mais pas très flexible.

Ensuite, j’ai testé l’injection dynamique. Ici, on lit le nom des classes depuis un fichier config.txt et on crée les objets avec reflection ("Class.forName(...)"). Ce qui m’a surpris, c’est qu’on peut complètement changer le DAO juste en éditant un fichier, sans toucher au code Java. C’est beaucoup plus flexible que l’injection statique, mais il faut faire attention aux erreurs dans les noms de classes. J’ai mis un moment à comprendre comment passer correctement le DAO au constructeur via reflection, mais après ça marche très bien.

La troisième méthode utilise Spring avec un fichier XML pour définir les beans et leurs relations. Dans config.xml, on indique quel DAO utiliser pour MetierImpl. Spring crée les objets et injecte les dépendances automatiquement. Ici, je n’ai presque rien à coder dans le main, ce qui est pratique quand on a beaucoup de classes. J’étais impressionné par la facilité de Spring XML, même si écrire le XML au début m’a pris un peu de temps.

Enfin, j’ai testé Spring avec annotations. J’ai utilisé "@Component" pour déclarer les classes comme beans, "@Autowired" pour que Spring injecte automatiquement le DAO dans MetierImpl, et "@Qualifier" pour choisir la bonne implémentation. C’est beaucoup plus moderne et propre que le XML, et j’ai vraiment aimé voir que tout est automatique. J’ai trouvé ça super pratique, et ça m’a donné envie d’utiliser les annotations partout pour mes futurs projets.

Avec ce projet, j’ai compris que le couplage faible rend le code beaucoup plus flexible et facile à maintenir. L’injection statique est simple mais pas pratique pour changer les implémentations, l’injection dynamique est plus flexible mais demande plus d’attention, et Spring rend l’injection de dépendances très simple et automatique. J’ai appris beaucoup sur comment structurer un projet Java de manière propre et modulable. J’ai aussi compris l’importance de bien séparer les responsabilités entre les couches DAO et métier et comment chaque méthode d’injection peut influencer la maintenance et l’évolution du code.

On utilise config.txt pour l’injection dynamique et config.xml pour Spring XML.
